message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setsolve(m)
m
}
b<-makeCacheMatrix(matrix(1:4),2,2)
makeCacheMatrix(matrix(1:4))
b<-makeCacheMatrix(matrix(1:4))
b
cachesolve(c)
b$get()
b <- makeCacheMatrix(matrix(c(1,3,2,4), nrow = 2, ncol = 2))
b$get()
cachesolve(c)
cachesolve(x)
cachesolve(m)
b$getsolve
b$setsolve
b$getsolve()
cachesolve(b)
b <- makeCacheMatrix(matrix(c(1,3,2,4), nrow = 2, ncol = 2))
cachesolve(b)
## This function creates a special
## "matrix" object that can cache
##its inverse
makeCacheMatrix <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setsolve <- function(solve) m <<- solve
getsolve <- function() m
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
## This function checks the cache
## for the inverse and, if not found
## computes the inverse
cachesolve <- function(x, ...) {
m <- x$getsolve()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setsolve(m)
m
}
makeCacheMatrix(1:4,2,2)
makeCacheMatrix(c(1,2,3,4),nrow=2,ncol=2)
makeCacheMatrix(c(1,2,3,4),nrow=2,ncol=2))
b<-makeCacheMatrix(c(1,2,3,4),nrow=2,ncol=2))
b<-makeCacheMatrix(matrix(c(1,2,3,4)nrow=2,ncol=2))
b<-makeCacheMatrix(matrix(c(1,2,3,4),nrow=2,ncol=2))
b
b$get()
cachesolve(b)
b<-makeCacheMatrix(matrix(c(1:4),nrow=2,ncol=2))
b
b$get()
## This function creates a special
## "matrix" object that can cache
##its inverse
makeCacheMatrix <- function(x = numeric()) {
s <- NULL
set <- function(y) {
x <<- y
s <<- NULL
}
get <- function() x
setsolve <- function(solve) s <<- solve
getsolve <- function() s
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
## This function checks the cache
## for the inverse and, if not found
## computes the inverse
cachesolve <- function(x, ...) {
m <- x$getsolve()
if(!is.null(s)) {
message("getting cached data")
return(s)
}
data <- x$get()
m <- solve(data, ...)
x$setsolve(s)
s
}
a<-makeCacheMatrix(matrix(c(1:4),nrow=2,ncol=2))
a
get$a
a$get()
cachesolve(a)
## This function creates a special
## "matrix" object that can cache
##its inverse
makeCacheMatrix <- function(x = numeric()) {
s <- NULL
set <- function(y) {
x <<- y
s <<- NULL
}
get <- function() x
setsolve <- function(solve) s <<- solve
getsolve <- function() s
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
## This function checks the cache
## for the inverse and, if not found
## computes the inverse
cachesolve <- function(x, ...) {
s <- x$getsolve()
if(!is.null(s)) {
message("getting cached data")
return(s)
}
data <- x$get()
s <- solve(data, ...)
x$setsolve(s)
s
}
a<-makeCacheMatrix(matrix(c(1:4),nrow=2,ncol=2))
a$get()
cachesolve(a)
## This function creates a special
## "matrix" object that can cache
##its inverse
makeCacheMatrix <- function(x = numeric()) {
s <- NULL
set <- function(y) {
x <<- y(matrix(),nrow, ncol)
s <<- NULL
}
get <- function() x
setsolve <- function(solve) s <<- solve
getsolve <- function() s
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
## This function checks the cache
## for the inverse and, if not found
## computes the inverse
cachesolve <- function(x, ...) {
s <- x$getsolve()
if(!is.null(s)) {
message("getting cached data")
return(s)
}
data <- x$get()
s <- solve(data, ...)
x$setsolve(s)
s
}
a<-makeCacheMatrix(1:4,2,2)
## This function creates a special
## "matrix" object that can cache
##its inverse
makeCacheMatrix <- function(x = numeric()) {
s <- NULL
set <- function(y) {
x <<- y(matrix=matrix(1:4),nrow=2, ncol=2)
s <<- NULL
}
get <- function() x
setsolve <- function(solve) s <<- solve
getsolve <- function() s
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
## This function checks the cache
## for the inverse and, if not found
## computes the inverse
cachesolve <- function(x, ...) {
s <- x$getsolve()
if(!is.null(s)) {
message("getting cached data")
return(s)
}
data <- x$get()
s <- solve(data, ...)
x$setsolve(s)
s
}
a<-makeCacheMatrix(1:4,2,2)
## This function creates a special
## "matrix" object that can cache
##its inverse
makeCacheMatrix <- function(x = numeric()) {
s <- NULL
set <- function(y) {
x <<- y
s <<- NULL
}
get <- function() x
setsolve <- function(solve) s <<- solve
getsolve <- function() s
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
## This function checks the cache
## for the inverse and, if not found
## computes the inverse
cachesolve <- function(x, ...) {
s <- x$getsolve()
if(!is.null(s)) {
message("getting cached data")
return(s)
}
data <- x$get()
s <- solve(data, ...)
x$setsolve(s)
s
}
a<-makeCacheMatrix(matrix(c(1:4),2,2))
a
a$gget()
a$get()
a<-makeCacheMatrix(matrix(c(1:25),5,5))
a$get()
cachesolve(a)
a<-makeCacheMatrix(rnorm(16),nrow=4,ncol=4))
a<-makeCacheMatrix(matrix(rnorm(16)),nrow=4,ncol=4))
a<-makeCacheMatrix(matrix(c(1:9))),nrow=3,ncol=3))
a<-makeCacheMatrix(matrix(c(1:9),nrow=3,ncol=3))
a$get()
cachesolve(a)
a<-makeCacheMatrix(matrix(c(1:4),nrow=2,ncol=2))
a$get()
cachesolve(a)
a<-makeCacheMatrix(matrix(c(1:4),nrow=2,ncol=2))
cachesolve(a)
a<-makeCacheMatrix(matrix(c(1:4),nrow=2,ncol=2))
a$get()
cachesolve(a)
## This function creates a special
## "matrix" object that can cache
##its inverse
makeCacheMatrix <- function(x = matrix()) {
s <- NULL
set <- function(y) {
x <<- y
s <<- NULL
}
get <- function() x
setsolve <- function(solve) s <<- solve
getsolve <- function() s
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
## This function checks the cache
## for the inverse and, if not found
## computes the inverse
cachesolve <- function(x=matrix(), ...) {
s <- x$getsolve()
if(!is.null(s)) {
message("getting cached data")
return(s)
}
data <- x$get()
s <- solve(data, ...)
x$setsolve(s)
s
}
a<-makeCacheMatrix(c(1:4),2,2)
a<-makeCacheMatrix(c(1:4),nrow=2,ncol=2)
a<-makeCacheMatrix(matrix(c(1:4),nrow=2,ncol=2))
a$get()
a<-makeCacheMatrix(matrix(c(1:4),nrow=2,ncol=2))
a$get()
cachesolve(a)
## This function creates a matrix object that can cache its inverse
makeCacheMatrix <- function(x = matrix()) {
## assumes 'x' is a square invertible matrix
s <- NULL
set <- function(y) {
x <<- y                        ## assigns value to object
s <<- NULL                     ## outside of function's environment
}
get <- function() x
setsolve <- function(solve) s <<- solve
getsolve <- function() s
list                               ##this list is used as the input to cacheSolve()
(set = set,                   ## set the matrix
get = get,                    ## get the matrix
setsolve = setsolve,          ## set the inverse
getsolve = getsolve)          ## get the inverse
}
## This function checks the cache for the inverse and, if not found computes the inverse
cachesolve <- function(x=matrix(), ...) {
s <- x$getsolve()               ## gets 'x' as the output of makeCacheMatrix()
if(!is.null(s)) {               ## checks if the inverse has already been calculated
message("getting cached data")  ## if so, gets it from the cache and skips the computation.
return(s)
}
data <- x$get()
s <- solve(data, ...)
x$setsolve(s)     ## sets the value of the inverse in the cache through the setsolve function.
s                 ## returns the inverse of the original
}
a<-makeCacheMatrix(matrix(c(1:4),nerow=2,ncol=2))
a$get()
a<-makeCacheMatrix(matrix(c(1:4),nrow=2,ncol=2))
a$get()
cachesolve(a)
b<-makeCacheMatrix(matrix(r, nrow=1000, ncol=1000))
b$get()
b<-makeCacheMatrix(matrix(rnorm(1000000), nrow=1000, ncol=1000))
b$get()
cachesolve(b)
?return
x=x
2=2
2>1
2=2
2>=2
3
3=3
"A"="A"
A=A
a
## This function creates a matrix object that can cache its inverse
makeCacheMatrix <- function(x = matrix()) {   ##'x' defined with argument requiring square, inversible matrix
s <- NULL                                 ## 's' set to NULL in immediate environment, (<<-solve in external environent)
set <- function(y) {                      ## nested 'set' with 'y' as argument
x <<- y                               ## 'x' set to 'y' in external environment
s <<- NULL                            ## 's' set to NULL also in external environment
}
get <- function() x                       ## creates 'get' function using 'x' from user-defined argument
setsolve <- function(solve) s <<- solve   ## Creates the setsolve sub-function, with 's' redefined as 'solve' in external environment
getsolve <- function() s                  ## creates the getsolve sub-function with 's' from the immediate environment
list                                      ## this generates the list input to cacheSolve()
(set = set,                           ## set the matrix
get = get,                           ## get the matrix
setsolve = setsolve,                 ## set the inverse
getsolve = getsolve)                 ## get the inverse
}
## This function checks the cache for the inverse and, if not found computes the inverse
cachesolve <- function(x=matrix(), ...) {     ##takes the list from makeCacheMatrix function and returns inverse from cache or calculation
s <- x$getsolve()                     ## gets 'x' (inverted matrix) from makeCaccheMatrix function output
if(!is.null(s)) {                     ## with 's' retrieved from cache, checks if its not NULL,
message("getting cached data")
return(s)                             ## if so, returns 's' from cache
}
data <- x$get()                           ## if else, gets the original matrix, and puts it in 'data'
s <- solve(data, ...)                     ## creates inverse and applies 'solve' function to 'data'
##    and puts it in 's' in immediate environment
x$setsolve(s)                             ## sets the value of the inverse in the cache through the setsolve function.
s                                         ## returns the inverse of the original
}
<-makeCacheMatrix(matrix(c(1:4),2,2))
<-makeCacheMatrix(matrix(c(1:4),nrow=2,ncol=2))
a<-makeCacheMatrix(matrix(c(1:4),nrow=2,ncol=2))
a$get()
cachesolve(a)
## This function creates a matrix object that can cache its inverse
makeCacheMatrix <- function(x = matrix()) {   ##'x' defined with argument requiring square, inversible matrix
s <- NULL                                 ## 's' set to NULL in immediate environment, (<<-solve in external environent)
print("Value of S in immediate environment")
print(s)
Sys.sleep(1)
set <- function(y) {                      ## nested 'set' with 'y' as argument
print("Value of set in immeidate envi")
print(set)
x <<- y                               ## 'x' set to 'y' in external environment
s <<- NULL                            ## 's' set to NULL also in external environment
}
get <- function() x                       ## creates 'get' function using 'x' from user-defined argument
setsolve <- function(solve) s <<- solve   ## Creates the setsolve sub-function, with 's' redefined as 'solve' in external environment
getsolve <- function() s                  ## creates the getsolve sub-function with 's' from the immediate environment
list                                      ## this generates the list input to cacheSolve()
(set = set,                           ## set the matrix
get = get,                           ## get the matrix
setsolve = setsolve,                 ## set the inverse
getsolve = getsolve)                 ## get the inverse
}
## This function checks the cache for the inverse and, if not found computes the inverse
cachesolve <- function(x=matrix(), ...) {     ##takes the list from makeCacheMatrix function and returns inverse from cache or calculation
s <- x$getsolve()                     ## gets 'x' (inverted matrix) from makeCaccheMatrix function output
if(!is.null(s)) {                     ## with 's' retrieved from cache, checks if its not NULL,
message("getting cached data")
return(s)                             ## if so, returns 's' from cache
}
data <- x$get()                           ## if else, gets the original matrix, and puts it in 'data'
s <- solve(data, ...)                     ## creates inverse and applies 'solve' function to 'data'
##    and puts it in 's' in immediate environment
x$setsolve(s)                             ## sets the value of the inverse in the cache through the setsolve function.
s                                         ## returns the inverse of the original
}
a<-makeCacheMatrix(matrix(c(1:4),nrow=2,ncol=2))
aget()
a$get()
## This function creates a matrix object that can cache its inverse
makeCacheMatrix <- function(x = matrix()) {   ##'x' defined with argument requiring square, inversible matrix
s <- NULL                                 ## 's' set to NULL in immediate environment
set <- function(y) {                      ## nested 'set' function with 'y' as argument
x <<- y                               ## 'x' set to 'y' in global environment
s <<- NULL                            ## 's' set to NULL in global environment
}
get <- function() x                       ## creates 'get' function using 'x' from user-defined argument
setsolve <- function(solve) s <<- solve   ## Creates the setsolve sub-function, with 's' redefined as 'solve' in global environment
getsolve <- function() s                  ## creates the getsolve sub-function with 's' from the immediate environment
list                                      ## this generates the list input to cacheSolve()
(set = set,                           ## set the matrix
get = get,                           ## get the matrix
setsolve = setsolve,                 ## set the inverse
getsolve = getsolve)                 ## get the inverse
}
## This function checks the cache for the inverse and, if not found computes the inverse
cachesolve <- function(x=matrix(), ...) {     ##takes the list from makeCacheMatrix function and returns inverse from cache or calculation
s <- x$getsolve()                     ## populates 's' with 'x' (inverted matrix) from makeCaccheMatrix function output
if(!is.null(s)) {                     ## with 's' retrieved from cache, checks if its not NULL,
message("getting cached data")
return(s)                             ## if so, returns 's' from cache
}
data <- x$get()                           ## if else, gets the original matrix, and puts it in 'data'
s <- solve(data, ...)                     ## creates inverse and applies 'solve' function to 'data'
##    and puts it in 's' in immediate environment
x$setsolve(s)                             ## sets the value of the inverse in the cache through the setsolve function.
s                                         ## returns the inverse of the original
}
makeCacheMatrix <- function(x = matrix()) {   ##'x' defined with argument requiring square, inversible matrix
s <- NULL                                 ## 's' set to NULL in immediate environment
set <- function(y) {                      ## nested 'set' function with 'y' as argument
x <<- y                               ## 'x' set to 'y' in global environment
s <<- NULL                            ## 's' set to NULL in global environment
}
get <- function() x                       ## creates 'get' function using 'x' from user-defined argument
setsolve <- function(solve) s <<- solve   ## Creates the setsolve sub-function, with 's' redefined as 'solve' in global environment
getsolve <- function() s                  ## creates the getsolve sub-function with 's' from the immediate environment
## this generates the list input to cacheSolve()
list (set = set, get = get, setsolve = setsolve, getsolve = getsolve)
}
a<-makeCacheMatrix(matrix(c(1:4),nrow=2,ncol=2))
a$get()
## This function creates a matrix object that can cache its inverse
makeCacheMatrix <- function(x = matrix()) {   ##'x' defined with argument requiring square, inversible matrix
s <- NULL                                 ## 's' set to NULL in immediate environment
set <- function(y) {                      ## nested 'set' function with 'y' as argument
x <<- y                               ## 'x' set to 'y' in global environment
s <<- NULL                            ## 's' set to NULL in global environment
}
get <- function() x                       ## creates 'get' function using 'x' from user-defined argument
setsolve <- function(solve) s <<- solve   ## Creates the setsolve sub-function, with 's' redefined as 'solve' in global environment
getsolve <- function() s                  ## creates the getsolve sub-function with 's' from the immediate environment
## this generates the list input to cacheSolve()
list (set = set,
get = get,
setsolve = setsolve,
getsolve = getsolve)
}
## This function checks the cache for the inverse and, if not found computes the inverse
cachesolve <- function(x=matrix(), ...) {     ##takes the list from makeCacheMatrix function and returns inverse from cache or calculation
s <- x$getsolve()                     ## populates 's' with 'x' (inverted matrix) from makeCaccheMatrix function output
if(!is.null(s)) {                     ## with 's' retrieved from cache, checks if its not NULL,
message("getting cached data")
return(s)                             ## if so, returns 's' from cache
}
data <- x$get()                           ## if else, gets the original matrix, and puts it in 'data'
s <- solve(data, ...)                     ## creates inverse and applies 'solve' function to 'data'
##    and puts it in 's' in immediate environment
x$setsolve(s)                             ## sets the value of the inverse in the cache through the setsolve function.
s                                         ## returns the inverse of the original
}
a<-makeCacheMatrix(matrix(c(1:4),nrow=2,ncol=2))
a$get()
## This function creates a matrix object that can cache its inverse
makeCacheMatrix <- function(x = matrix()) {   ##'x' defined with argument requiring square, inversible matrix
s <- NULL                                 ## 's' set to NULL in immediate environment
set <- function(y) {                      ## nested 'set' function with 'y' as argument
x <<- y                               ## 'x' set to 'y' in global environment
s <<- NULL                            ## 's' set to NULL in global environment
}
get <- function() x                       ## creates 'get' function using 'x' from user-defined argument
setsolve <- function(solve) s <<- solve   ## Creates the setsolve sub-function
getsolve <- function() s                  ## creates the getsolve sub-function
## this generates the list input to cacheSolve()
list (set = set,
get = get,
setsolve = setsolve,
getsolve = getsolve)
}
## This function checks the cache for the inverse and, if not found computes the inverse
cachesolve <- function(x=matrix(), ...) {     ##takes the list from makeCacheMatrix function and returns inverse from cache or calculation
s <- x$getsolve()                     ## populates 's' with 'x' (inverted matrix) from makeCacheMatrix function output
if(!is.null(s)) {                     ## with 's' retrieved from cache, checks if its not NULL,
message("getting cached data")
return(s)                             ## if so, returns 's' from cache
}
data <- x$get()                           ## if else, gets the original matrix, and puts it in 'data'
s <- solve(data, ...)                     ## creates inverse and applies 'solve' function to 'data'
##    and puts it in 's' in immediate environment
x$setsolve(s)
s
}
a<-makeCacheMatrix(matrix(c(1:4),nrow=2,ncol=2))
a$get()
cachesolve(a)
